#Linux 环境
---
## Linux 硬件搭配
**因為，各個元件或裝置在Linux底下都是『一個檔案！』**  
CPU
RAM:主記憶體是越大越好！事實上在Linux伺服器中，主記憶體的重要性比CPU還要高的多！因為如果主記憶體不夠大， 就會使用到硬碟的記憶體置換空間(swap)。 而由計算機概論的內容我們知道硬碟比記憶體的速度要慢的多， 所以主記憶體太小可能會影響到整體系統的效能的！
#### 各硬體裝置在Linux中的檔名
『在Linux系統中，每個裝置都被當成一個檔案來對待』 舉例來說，SATA介面的硬碟的檔案名稱即為/dev/sd[a-d]，其中， 括號內的字母為a-d當中的任意一個，亦即有/dev/sda, /dev/sdb, /dev/sdc, 及 /dev/sdd這四個檔案的意思。
>在Linux這個系統當中，幾乎所有的硬體裝置檔案都在/dev這個目錄內， 所以你會看到/dev/sda, /dev/sr0等等的檔名喔。

**各种设备在Linux中的名字**
![设备名称](/os_note/linux_environment/picture/各类设备名称.png)
usb,sata /dev/sd[a-p]
floppy disk /dev/fd[0-1]
mouse /dev/mouse
cdrom /dev/cdrom

**此外， 如果你的機器使用的是跟網際網路供應商 (ISP) 申請使用的雲端機器，這時可能會得到的是虛擬機器。為了加速，虛擬機器內的磁碟是使用模擬器產生， 該模擬器產生的磁碟檔名為 /dev/vd[a-p] 系列的檔名喔！要注意！要注意！**

## 磁碟分割
我們知道一塊磁碟是可以被分割成多個分割槽的(partition)，以舊有的Windows觀點來看，你可能會有一顆磁碟並且將他分割成為C:, D:, E:槽對吧！那個C, D, E就是分割槽(partition)囉。但是Linux的裝置都是以檔案的型態存在，那分割槽的檔名又是什麼？ 如何進行磁碟分割？磁碟分割有哪些限制？目前的 BIOS 與 UEFI 分別是啥？MSDOS 與 GPT 又是啥？ 都是我們這個小節所要探討的內容囉。

>例題：
如果你的PC上面有兩個SATA磁碟以及一個USB磁碟，而主機板上面有六個SATA的插槽。這兩個SATA磁碟分別安插在主機板上的SATA1, SATA5插槽上， 請問這三個磁碟在Linux中的裝置檔名為何？
答：
由於是使用偵測到的順序來決定裝置檔名，並非與實際插槽代號有關，因此裝置的檔名如下：
SATA1插槽上的檔名：/dev/sda
SATA5插槽上的檔名：/dev/sdb
USB磁碟(開機完成後才被系統捉到)：/dev/sdc

我們在計算機概論談過磁碟的組成主要有磁碟盤、機械手臂、磁碟讀取頭與主軸馬達所組成， 而資料的寫入其實是在磁碟盤上面。**磁碟盤上面又可細分出磁區(Sector)與磁軌(Track)兩種單位， 其中磁區的物理量設計有兩種大小，分別是 512bytes 與 4Kbytes。**假設磁碟只有一個磁碟盤，那麼磁碟盤有點像底下這樣：
![磁盘设计](/os_note/linux_environment/picture/磁盘示意.png)
**其實整顆磁碟的第一個磁區特別的重要，因為他記錄了整顆磁碟的重要資訊！** 早期磁碟第一個磁區裡面含有的重要資訊我們稱為**MBR (Master Boot Record) 格式**，但是由於近年來磁碟的容量不斷擴大，造成讀寫上的一些困擾， 甚至有些大於 2TB 以上的磁碟分割已經讓某些作業系統無法存取。因此後來又多了一個新的磁碟分割格式，稱為 **GPT (GUID partition table)！** 這兩種分割格式與限制不太相同啦！

那麼分割表又是啥？其實妳剛剛拿到的整顆硬碟就像一根原木，你必須要在這根原木上面切割出你想要的區段， 這個區段才能夠再製作成為你想要的家具！如果沒有進行切割，那麼原木就不能被有效的使用。 同樣的道理，你必須要針對你的硬碟進行分割，這樣硬碟才可以被你使用的！
### MSDOS(MBR) 與 GPT 磁碟分割表(partition table) 
在前一小節的圖示中， 我們有看到『開始與結束磁軌』吧？而通常磁碟可能有多個磁碟盤，**所有磁碟盤的同一個磁軌我們稱為磁柱 (Cylinder)， 通常那是檔案系統的最小單位，也就是分割槽的最小單位啦！** 為什麼說『通常』呢？因為近來有 GPT 這個可達到 64bit 紀錄功能的分割表， 現在我們甚至可以使用磁區 (sector) 號碼來作為分割單位哩！厲害了！ 所以說，我們就是利用參考對照磁柱或磁區號碼的方式來處理啦！

<span id="MBR_lable">MBR</span>

#### MSDOS (MBR) 分割表格式與限制
早期的 Linux 系統為了相容於 Windows 的磁碟，因此使用的是支援 Windows 的**MBR(Master Boot Record, 主要開機紀錄區)** 的方式來處理開機管理程式與分割表！而**開機管理程式紀錄區與分割表則通通放在磁碟的第一個磁區， 這個磁區通常是 512bytes 的大小 (舊的磁碟磁區都是 512bytes 喔！)，** 所以說，第一個磁區 512bytes 會有這兩個資料：
- **主要開機記錄區(Master Boot Record, MBR)：可以安裝開機管理程式的地方，有446 bytes**
- **分割表(partition table)：記錄整顆硬碟分割的狀態，有64 bytes**

<font color=red>由於分割表所在區塊僅有64 bytes容量，因此最多僅能有四組記錄區，每組記錄區記錄了該區段的啟始與結束的磁柱號碼。</font> 若將硬碟以長條形來看，然後將磁柱以直條圖來看，那麼那64 bytes的記錄區段有點像底下的圖示：
<div align=center><img src="/os_note/linux_environment/picture/mbr%20disk%20partition-1.png"/></div>
假設上面的硬碟裝置檔名為/dev/sda時，那麼這四個分割槽在Linux系統中的裝置檔名如下所示， 重點在於檔名後面會再接一個數字，這個數字與該分割槽所在的位置有關喔! 

- P1:/dev/sda1
- P2:/dev/sda2
- P3:/dev/sda3
- P4:/dev/sda4

上圖中我們假設硬碟只有400個磁柱，共分割成為四個分割槽，第四個分割槽所在為第301到400號磁柱的範圍。 當你的作業系統為Windows時，那麼第一到第四個分割槽的代號應該就是C, D, E, F。當你有資料要寫入F槽時， 你的資料會被寫入這顆磁碟的301~400號磁柱之間的意思。
**由於分割表就只有64 bytes而已，最多只能容納四筆分割的記錄， 這四個分割的記錄被稱為主要(Primary)或延伸(Extended)分割槽。**  根據上面的圖示與說明，我們可以得到幾個重點資訊：
- 其實所謂的『分割』只是針對那個64 bytes的分割表進行設定而已！
- 硬碟預設的分割表僅能寫入四組分割資訊
- 這四組分割資訊我們稱為主要(Primary)或延伸(Extended)分割槽
- 分割槽的最小單位『通常』為磁柱(cylinder)
- 當系統要寫入磁碟時，一定會參考磁碟分割表，才能針對某個分割槽進行資料的處理

**為啥要分割啊？**
- 資料的安全性：
- 系統的效能考量：

在Windows/Linux系統中， 我們是透過剛剛談到的延伸分割(Extended)的方式來處理的啦！延伸分割的想法是： 既然第一個磁區所在的分割表只能記錄四筆資料， 那我可否利用額外的磁區來記錄更多的分割資訊？實際上圖示有點像底下這樣：
<div align =center><img src="/os_note/linux_environment/picture/partition-2.png"/></div>

P1為主要分割，而P2則為延伸分割。**請注意， 延伸分割的目的是使用額外的磁區來記錄分割資訊，延伸分割本身並不能被拿來格式化。** 然後我們可以透過延伸分割所指向的那個區塊繼續作分割的記錄**  
如上圖右下方那個區塊有繼續分割出五個分割槽， **這五個由延伸分割繼續切出來的分割槽，就被稱為邏輯分割槽(logical partition)。** 同時注意一下，由於邏輯分割槽是由延伸分割繼續分割出來的，所以他可以使用的磁柱範圍就是延伸分割所設定的範圍喔！ 也就是圖中的101~400啦！
- P1:/dev/sda1
- P2:/dev/sda2
- L1:/dev/sda5
- L2:/dev/sda6
- L3:/dev/sda7
- L4:/dev/sda8
- L5:/dev/sda9

仔細看看，**怎麼裝置檔名沒有/dev/sda3與/dev/sda4呢？因為前面四個號碼都是保留給Primary或Extended用的嘛！ 所以邏輯分割槽的裝置名稱號碼就由5號開始了！** 這在 MBR 方式的分割表中是個很重要的特性，不能忘記喔！

**MBR 主要分割、延伸分割與邏輯分割的特性我們作個簡單的定義囉：**
- 主要分割與延伸分割最多可以有四筆(硬碟的限制)
- 延伸分割最多只能有一個(作業系統的限制)
- 邏輯分割是由延伸分割持續切割出來的分割槽；
- 能夠被格式化後，作為資料存取的分割槽為主要分割與邏輯分割。延伸分割無法格式化；
- 邏輯分割的數量依作業系統而不同，在Linux系統中SATA硬碟已經可以突破63個以上的分割限制；

事實上，分割是個很麻煩的東西，因為他是以磁柱為單位的『連續』磁碟空間， 且延伸分割又是個類似獨立的磁碟空間，所以在分割的時候得要特別注意。我們舉底下的例子來解釋一下好了：


**如果延伸分割被破壞，所有邏輯分割將會被刪除**
>问1：如果我想將一顆大硬碟『暫時』分割成為四個partitions，同時還有其他的剩餘容量可以讓我在未來的時候進行規劃， 我能不能分割出四個Primary？若不行，那麼你建議該如何分割？

>答：**由於Primary+Extended最多只能有四個，其中Extended最多只能有一個**，這個例題想要分割出四個分割槽且還要預留剩餘容量， 因此P+P+P+P的分割方式是不適合的。因為如果使用到四個P，則即使硬碟還有剩餘容量， 因為無法再繼續分割，所以剩餘容量就被浪費掉了。
假設你想要將所有的四筆記錄都花光，那麼P+P+P+E是比較適合的。所以可以用的四個partitions有3個主要及一個邏輯分割， 剩餘的容量在延伸分割中。
如果你要分割超過4槽以上時，一定要有Extended分割槽，而且必須將所有剩下的空間都分配給Extended， 然後再以logical的分割來規劃Extended的空間。 另外，考慮到磁碟的連續性，一般建議將Extended的磁柱號碼分配在最後面的磁柱內。

>问2：假如我的PC有兩顆SATA硬碟，我想在第二顆硬碟分割出6個可用的分割槽(可以被格式化來存取資料之用)， 那每個分割槽在Linux系統下的裝置檔名為何？且分割類型各為何？至少寫出兩種不同的分割方式。
>答2：
P1+P2+P3+L1+L2+L3
P1：/dev/sdb1
P2: /dev/sdb2
P3: /dev/sdb3
L1: /dev/sdb5
L2: /dev/sdb6
L3: /dev/sdb7
P1+L1+L2+L3+L4+L5
P1：/dev/sdb1
L1: /dev/sdb5
L2: /dev/sdb6
L3: /dev/sdb7
L4: /dev/sdb8
L5: /dev/sdb9

MBR 分割表除了上述的主分割、延伸分割、邏輯分割需要注意之外，由於每組分割表僅有 16bytes 而已，因此可紀錄的資訊真的是相當有限的！ 所以，在過去 MBR 分割表的限制中經常可以發現如下的問題：
- 作業系統無法抓取到 2.2T 以上的磁碟容量！
- MBR 僅有一個區塊，若被破壞後，經常無法或很難救援。
- MBR 內的存放開機管理程式的區塊僅 446bytes，無法容納較多的程式碼。

##### MBR最大容量限制
分区表64B=4*16B
**16B中：只有13，14，15，16 用作总扇区数，即只有4B=32bit，总扇区数<=2^32
1-引导符号
（2，3，4） 起始（磁头，扇区，柱面号）
5-分区类型（fat16、fat32、扩展、ntfs）
（6，7，8） 结束（磁头，扇区，柱面号）
9，10，11，12 使用的扇区数目 
13，14，15，16 总扇区数

一般一个扇区容量为512B，总容量为512*2^32=2^41B=2^31KB=2^21MB=2^11GB=2TB

#### GUID partition table, GPT 磁碟分割表 
為了相容於所有的磁碟，因此在磁區的定義上面， 大多會使用所謂的邏輯區塊位址(Logical Block Address, LBA)來處理。GPT 將磁碟所有區塊以此 LBA(預設為 512bytes 喔！) 來規劃，而第一個 LBA 稱為 LBA0 (從 0 開始編號)。
與 MBR 僅使用第一個 512bytes 區塊來紀錄不同， GPT 使用了 34 個 LBA 區塊來紀錄分割資訊！同時與過去 MBR 僅有一的區塊，被幹掉就死光光的情況不同， GPT 除了前面 34 個 LBA 之外，整個磁碟的最後 33 個 LBA 也拿來作為另一個備份！這樣或許會比較安全些吧！詳細的結構有點像底下的模樣(註1)：
<div align =center><img src="/os_note/linux_environment/picture/gpt_partition_1.jpg"/></div>

- LBA0 (MBR 相容區塊)  **保护磁盘** 
與 MBR 模式相似的，這個相容區塊也分為兩個部份，一個就是跟之前 446 bytes 相似的區塊，儲存了第一階段的開機管理程式！ **而在原本的分割表的紀錄區內，這個相容模式僅放入一個特殊標誌的分割，用來表示此磁碟為 GPT 格式之意。** 而不懂 GPT 分割表的磁碟管理程式， 就不會認識這顆磁碟，除非用戶有特別要求要處理這顆磁碟，否則該管理軟體不能修改此分割資訊，進一步保護了此磁碟喔！
- LBA1 (GPT 表頭紀錄)
這個部份紀錄了分割表本身的位置與大小，同時紀錄了備份用的 GPT 分割 (就是前面談到的在最後 34 個 LBA 區塊) 放置的位置， 同時放置了分割表的檢驗機制碼 (CRC32)，作業系統可以根據這個檢驗碼來判斷 GPT 是否正確。若有錯誤，還可以透過這個紀錄區來取得備份的 GPT(磁碟最後的那個備份區塊) 來恢復 GPT 的正常運作！
- LBA2-33 (實際紀錄分割資訊處)
從 LBA2 區塊開始，每個 LBA 都可以紀錄 4 筆分割紀錄，所以在預設的情況下，總共可以有 4 * 32 = 128 筆分割紀錄喔！因為每個 LBA 有 512bytes，因此每筆紀錄用到 128 bytes 的空間，除了每筆紀錄所需要的識別碼與相關的紀錄之外，GPT 在每筆紀錄中分別提供了 64bits 來記載開始/結束的磁區號碼，因此，GPT 分割表對於單一分割槽來說， 他的最大容量限制就會在『 2^64 * 512bytes = 2^63 * 1Kbytes = 2^33*TB = 8 ZB 』，要注意 1ZB = 2^30TB 啦！ 你說有沒有夠大了？
現在 GPT 分割預設可以提供多達 128 筆紀錄，而在 Linux 本身的核心裝置紀錄中，針對單一磁碟來說，雖然過去最多只能到達 15 個分割槽，不過由於 Linux kernel 透過 udev 等方式的處理，現在 Linux 也已經沒有這個限制在了！ 此外，GPT 分割已經沒有所謂的主、延伸、邏輯分割的概念，既然每筆紀錄都可以獨立存在， 當然每個都可以視為是主分割！每一個分割都可以拿來格式化使用喔！

### 開機流程中的 BIOS 與 UEFI 開機檢測程式
#### BIOS 搭配 MBR/GPT 的開機流程
整個開機流程到作業系統之前的動作應該是這樣的：
1. BIOS：開機主動執行的韌體，會認識第一個可開機的裝置
2. MBR：第一個可開機裝置的第一個磁區內的主要開機記錄區塊，內含開機管理程式；
3. 開機管理程式(boot loader)：一支可讀取核心檔案來執行的軟體；
4. 核心檔案：開始作業系統的功能...


**BIOS上电** 
BIOS則是一個寫入到主機板上的一個韌體(再次說明， 韌體就是寫入到硬體上的一個軟體程式)。這個BIOS就是在開機的時候，電腦系統會主動執行的第一個程式了！
接下來BIOS會去分析電腦裡面有哪些儲存設備，我們以硬碟為例，BIOS會依據使用者的設定去取得能夠開機的硬碟， 並且到該硬碟裡面去讀取第一個磁區的MBR位置。 MBR這個僅有446 bytes的硬碟容量裡面會放置最基本的開機管理程式， 此時BIOS就功成圓滿，而接下來就是MBR內的開機管理程式的工作了。
> 电脑启动后，对于x86系列的CPU，一加电就将指令寄存器设置为：0xFFFF0000，表示CPU开始从0xFFFF0000这个内存中取出一条指令执行，通常在0xFFFF0000处是一条地址转跳指令，转向BIOS的入口。

> BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做"硬件自检"（Power-On Self-Test），缩写为POST。如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。

> BIOS设置里有一个选项是Boot Sequence，可以设置外部存储设备的启动顺序，排在前面的设备就是优先转交控制权的设备。硬件自检完成，BIOS的主要工作就是加载引导扇区。BIOS根据Boot Sequence中的顺序，将最前面的存储设备的引导扇区的内容加载到内存中，并跳转到引导程序的第一条指令。

> (MBR)BIOS将所检查外部存储设备的第一个扇区（512B）载入内存，放在0x00007C00处，如果一个扇区的最后两个字节是“55 AA”，那么这就是一个引导扇区，这个外部存储设备也就是一块可引导盘。通常这个大小为512B的程序就称为引导程序（boot）。如果最后两个字节不是“55 AA”，那么BIOS就检查下一个外部存储设备。如果没有其他启动介质，则显示 ”No ROM BASIC” ，然后死机。

**MBR** 
如<a href="#MBR_lable">上文MBR提到</a>
由上面的說明我們會知道，BIOS與MBR都是硬體本身會支援的功能，至於Boot loader則是作業系統安裝在MBR上面的一套軟體了。由於MBR僅有446 bytes而已，因此這個開機管理程式是非常小而美的**boot loader** 這個boot loader的主要任務有底下這些項目：
- 提供選單：使用者可以選擇不同的開機項目，這也是多重開機的重要功能！
- 載入核心檔案：直接指向可開機的程式區段來開始作業系統；
- 轉交其他loader：將開機管理功能轉交給其他loader負責。

上面前兩點還容易理解，但是第三點很有趣喔！那表示你的電腦系統裡面可能具有兩個以上的開機管理程式呢！ 有可能嗎？我們的硬碟不是只有一個MBR而已？是沒錯啦！但是開機管理程式除了可以安裝在MBR之外， 還可以安裝在每個分割槽的開機磁區(boot sector)喔！瞎密？分割槽還有各別的開機磁區喔？ 沒錯啊！這個特色才能造就『多重開機』的功能啊！
**双系统原理** 
我們舉一個例子來說，假設你的個人電腦只有一個硬碟，裡面切成四個分割槽，其中第一、二分割槽分別安裝了Windows及Linux， 你要如何在開機的時候選擇用Windows還是Linux開機呢？假設MBR內安裝的是可同時認識Windows/Linux作業系統的開機管理程式， 那麼整個流程可以圖示如下：
<div align=center><img src="/os_note/linux_environment/picture/loader.gif"></div>
在上圖中我們可以發現，MBR的開機管理程式提供兩個選單，選單一(M1)可以直接載入Windows的核心檔案來開機； 選單二(M2)則是將開機管理工作交給第二個分割槽的開機磁區(boot sector)。當使用者在開機的時候選擇選單二時， 那麼整個開機管理工作就會交給第二分割槽的開機管理程式了。 當第二個開機管理程式啟動後，該開機管理程式內(上圖中)僅有一個開機選單，因此就能夠使用Linux的核心檔案來開機囉。 這就是多重開機的工作情況啦！我們將上圖作個總結：

- 每個分割槽都擁有自己的開機磁區(boot sector)
- 圖中的系統槽為第一及第二分割槽，
- 實際可開機的核心檔案是放置到各分割槽內的！
- loader只會認識自己的系統槽內的可開機核心檔案，以及其他loader而已；
- loader可直接指向或者是間接將管理權轉交給另一個管理程式。

**先安装Windows再安装Linux** 
>Linux在安裝的時候，你可以選擇將開機管理程式安裝在MBR或各別分割槽的開機磁區， 而且Linux的loader可以手動設定選單(就是上圖的M1, M2...)，所以你可以在Linux的boot loader裡面加入Windows開機的選項；

>Windows在安裝的時候，他的安裝程式會主動的覆蓋掉MBR以及自己所在分割槽的開機磁區，你沒有選擇的機會， 而且他沒有讓我們自己選擇選單的功能。

因此，如果先安裝Linux再安裝Windows的話，那MBR的開機管理程式就只會有Windows的項目，而不會有Linux的項目 (因為原本在MBR內的Linux的開機管理程式就會被覆蓋掉)。 那需要重新安裝Linux一次嗎？當然不需要，你只要用盡各種方法來處理MBR的內容即可。 例如利用Linux的救援模式來挽救MBR啊！

####UEFI BIOS 搭配 GPT 開機的流程
我們現在知道 **GPT 可以提供到 64bit 的定址** ，然後也能夠使用較大的區塊來處理開機管理程式。但是 BIOS 其實不懂 GPT 耶！還得要透過 GPT 提供相容模式才能夠讀寫這個磁碟裝置～而且 **BIOS 僅為 16 位元的程式** ，在與現階段新的作業系統接軌方面有點弱掉了！ 為了解決這個問題，因此就有了 UEFI (Unified Extensible Firmware Interface) 這個統一可延伸韌體界面的產生。
UEFI 主要是想要取代 BIOS 這個韌體界面，因此我們也稱 UEFI 為 UEFI BIOS 就是了。**UEFI 使用 C 程式語言** ，比起使用組合語言的傳統 BIOS 要更容易開發！也因為使用 C 語言來撰寫，因此如果開發者夠厲害，甚至可以在 UEFI 開機階段就讓該系統了解 TCP/IP 而直接上網！ 根本不需要進入作業系統耶！這讓小型系統的開發充滿各式各樣的可能性！
![bios 和 uefi](/os_note/linux_environment/picture/bios%20or%20uefi.png)
>從上頭我們可以發現，與傳統的 BIOS 不同，UEFI 簡直就像是一個低階的作業系統～甚至於連主機板上面的硬體資源的管理， 也跟作業系統相當類似，只需要載入驅動程式即可控制操作。同時由於程式控制得宜，一般來說，使用 UEFI 介面的主機，在開機的速度上要比 BIOS 來的快上許多！ 因此很多人都覺得 UEFI 似乎可以發展成為一個很有用的作業系統耶～不過，關於這個，你無須擔心未來除了 Linux 之外，還得要增加學一個 UEFI 的作業系統啦！為啥呢？
UEFI 當初在發展的時候，就制定一些控制在裡頭，包括硬體資源的管理使用**輪詢 (polling)**  的方式來管理，與 BIOS 直接了解 CPU 以中斷的方式來管理比較， 這種 polling 的效率是稍微慢一些的，另外，**UEFI 並不能提供完整的快取功能** ，因此執行效率也沒有辦法提昇。不過由於載入所有的 UEFI 驅動程式之後， 系統會開啟一個類似作業系統的 shell 環境，使用者可以此環境中執行任意的 UEFI 應用程式，而且效果比 MSDOS 更好哩。

>此外，由於過去 cracker 經常藉由 BIOS 開機階段來破壞系統，並取得系統的控制權，因此 UEFI 加入了一個所謂的安全啟動 (secure boot) 機制， 這個機制代表著即將開機的作業系統必須要被 UEFI 所驗證，否則就無法順利開機！微軟用了很多這樣的機制來管理硬體。 不過加入這個機制後，許多的作業系統，包括 Linux ，就很有可能無法順利開機喔！所以，某些時刻，你可能得要將 UEFI 的 secure boot 功能關閉， 才能夠順利的進入 Linux 哩！ (這一點讓自由軟體工作者相當感冒啦！)
另外，與 BIOS 模式相比，雖然 UEFI 可以直接取得 GPT 的分割表，不過最好依舊擁有 BIOS boot 的分割槽支援， 同時，為了與 windows 相容，並且提供其他第三方廠商所使用的 UEFI 應用程式儲存的空間，你必須要格式化一個 vfat 的檔案系統， 大約提供 512MB 到 1G 左右的容量，以讓其他 UEFI 執行較為方便。

### Linux安裝模式下，磁碟分割的選擇(極重要)
#### 目錄樹結構 (directory tree)
所謂的目錄樹架構(directory tree)就是以根目錄為主，然後向下呈現分支狀的目錄結構的一種檔案架構。 所以，整個目錄樹架構最重要的就是那個根目錄(root directory)，這個根目錄的表示方法為一條斜線『/』， 所有的檔案都與目錄樹有關。目錄樹的呈現方式如下圖所示：
<div align=center><img src="/os_note/linux_environment/picture/dirtree.gif"></div>
如上圖所示，所有的檔案都是由根目錄(/)衍生來的，而次目錄之下還能夠有其他的資料存在。上圖中長方形為目錄， 波浪形則為檔案。那當我們想要取得mydata那個檔案時，系統就得由根目錄開始找，然後找到home接下來找到dmtsai， 最終的檔名為：/home/dmtsai/mydata的意思。

我們現在知道整個Linux系統使用的是目錄樹架構，但是我們的檔案資料其實是放置在磁碟分割槽當中的， 現在的問題是『如何結合目錄樹的架構與磁碟內的資料』呢？ 這個時候就牽扯到『掛載(mount)』的問題啦！

#### 檔案系統與目錄樹的關係(掛載)
所謂的『掛載』就是利用一個目錄當成進入點，將磁碟分割槽的資料放置在該目錄下； 也就是說，進入該目錄就可以讀取該分割槽的意思。這個動作我們稱為『掛載』，那個進入點的目錄我們稱為『掛載點』。 由於整個Linux系統最重要的是根目錄，因此根目錄一定需要掛載到某個分割槽的。 至於其他的目錄則可依使用者自己的需求來給予掛載到不同的分割槽。


## 2.5 本章習題

- 請寫下下列配備中，在 Linux 的裝置檔名：
SATA硬碟：/dev/sd[a-d]
CDROM：/dev/scd[0-1] (通用)
印表機：/dev/lp[0-15]
軟碟機：/dev/fd[0-1]
